var n="<script>\n  /**\n * 遍历树数据节点，查找符合条件的节点\n * @param {Array|Object} data 数据树，如 {id:1, children:[{id:2}]}\n * @param {Boolean} isFindOne 是否只找最先符合条件的一个\n * @param {Function} fn 查找回调函数，回调参数：item 节点，\n * index节点当前兄弟节点中的索引，data 查找的数据树，函数返回true表示符合条件\n * @param {string} [field=children] 子级字段名称\n * @returns {Array|Object} 查找结果，isFindOne为true时返回Object， false时返回Array\n */\nfunction traverse(data = [], isFindOne, fn, field = 'children') {\n  let result = []\n  data = Array.isArray(data) ? data : [data]\n  for (let i = 0, len = data.length; i < len; i++) {\n    const item = data[i]\n    const checked = fn(item, i, data)\n    const children = item[field]\n    if (checked) {\n      result.push(item)\n      if (isFindOne) break\n    }\n    if (children) {\n      const child = traverse(children, isFindOne, fn, field)\n      if (child) result = result.concat(child)\n    }\n  }\n  return isFindOne ? result[0] || null : result\n}\n<\/script>\n",e='<script>\n/**\n * 深拷贝一个对象\n * @param obj  json对象\n */\nfunction deepClone(obj) {\n  const result = Array.isArray(obj) ? [] : {}\n  if (obj && typeof obj === "object") {\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        if (obj[key] && typeof obj[key] === "object") {\n          result[key] = Vue.prototype.deepClone(obj[key])\n        } else {\n          result[key] = obj[key]\n        }\n      }\n    }\n  }\n  return result\n}\n<\/script>\n',t="<script>\nlet debounceTimer = null // 防抖方法-定时器对象\n/**\n * @desc 函数防抖\n * @param func 函数\n * @param wait 延迟执行毫秒数\n * @param immediate true 表立即执行，false 表非立即执行\n */\n function debounce (func, wait, immediate = false) {\n    let context = this // 获取debounce执行作用域的this\n    let args = arguments  // 获取参数\n\n    if (debounceTimer) clearTimeout(debounceTimer)\n    if (immediate) {\n        const callNow = !debounceTimer\n        debounceTimer = setTimeout(() => {\n            debounceTimer = null\n        }, wait)\n        if (callNow) func.apply(context, args)\n    } else {\n        debounceTimer = setTimeout(function() {\n            debounceTimer = null\n            func.apply(context, args)\n        }, wait)\n    }\n }\n<\/script>\n",r="<script>\nlet throttlePreious = 0 // 节流记录的时间戳\nlet throttleTimer = null // 节流定时器对象\n\n/**\n * @desc 函数节流\n * @param func 函数\n * @param wait 延迟执行毫秒数\n * @param type 1 表时间戳版（立即执行） 2 表定时器版（延迟执行）\n */\nfunction throttle (func, wait, type  = 1) {\n    let context = this // 获取debounce执行作用域的this\n    let args = arguments   // 获取参数\n    if (type === 1) {\n        let now = Date.now()\n        // 当前时间 - 记录的时间 > 设定的时间间隔\n        if (now - throttlePreious > wait) {\n            func.apply(context, args)\n            throttlePreious = now\n        }\n    } else if (type === 2) {\n        if (!throttleTimer) {\n            throttleTimer = setTimeout(() => {\n                throttleTimer = null\n                func.apply(context, args)\n            }, wait)\n        }\n    }\n}\n<\/script>\n",a='<script>\n/**\n * 生成随机GUID\n * @return {string}\n */\nfunction guid() {\n  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"\n    .replace(/[xy]/g, function(c) {\n      const r = (Math.random() * 16) | 0,\n        v = c === "x" ? r : (r & 0x3) | 0x8;\n      return v.toString(16);\n    })\n    .toUpperCase();\n}\n<\/script>\n',i='<script>\n/**\n * 生成唯一id\n * @return {string}\n */\nfunction uid() {\n  const rnd = Math.floor(Math.random() * 1000);\n  const timestamp = new Date().getTime();\n  return [timestamp, rnd].join("");\n}\n<\/script>\n',s="<script>\n/**\n * 获取变量类型\n * @param x\n * @param type\n * @returns {*|string | boolean}\n */\nfunction getType(x, type) {\n  let result = /^\\[object (.*)\\]$/.exec(Object.prototype.toString.call(x))[1]\n  return type ? result === type : result\n}\n<\/script>\n",c="<script>\n/**\n * entries:方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对\n * 循环数组(类似数组的forEach函数，支持递归循环)\n * @param arr 循环的数组\n * @param callback 循环回调 这里只是定义\n * @param parent 上一级,父级的值\n * @param parentIndexes 上一级索引路径\n * @param deep 是否递归\n * @param deepKey 递归的key\n */\nfunction forEach(arr = [], callback, { parent = {}, parentIndexes = [], deep = true, deepKey = 'children' } = {}) {\n  for (let [index, item] of arr.entries()) {\n    const indexes = [].concat(parentIndexes)\n    func.is(callback) && callback(item, index, parent, indexes)\n\n    if (deep && isArray(item[deepKey]) && item[deepKey].length > 0) {\n      indexes.push(index)\n      forEach(item[deepKey], callback, {\n        parent: item, // 父亲路由值\n        parentIndexes: indexes,\n        deep,\n        deepKey\n      })\n    }\n  }\n}\n<\/script>\n",o="<script>\n/**\n * 读取图片\n * @param src\n * @returns {Promise<any>}\n */\nfunction loadImage (src) {\n  return new Promise((resolve, reject) => {\n    const image = new Image()\n    image.onload = () => {\n      resolve(image)\n    }\n    image.onerror = (e) => {\n      reject(e)\n    }\n    image.src = src\n  })\n}\n<\/script>\n",l="<script>\n/**\n * base64数据转blob对象\n * @param url\n * @return {Blob}\n */\nfunction dataURLToBlob (url) {\n  const arr = url.split(',')\n  const mime = arr[0].match(/:(.*?);/)[1]\n  const bstr = atob(arr[1])\n  let n = bstr.length\n  const u8arr = new Uint8Array(n)\n  while (n--) {\n    u8arr[n] = bstr.charCodeAt(n)\n  }\n  return new Blob([u8arr], { type: mime })\n}\n<\/script>\n";export{t as a,r as b,s as c,e as d,l as e,c as f,a as g,o as l,n as t,i as u};
